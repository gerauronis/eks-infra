# Default values for kometa.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: nginx
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  className: alb
  annotations:
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:us-east-1:202533518394:certificate/f89b813d-7834-49e0-a23f-186d30037927,arn:aws:acm:us-east-1:202533518394:certificate/8fede441-dc3e-4211-9f79-785d9a26ddc1,arn:aws:acm:us-east-1:202533518394:certificate/34e171ec-b287-4a4a-b0ea-d02c16cfff2b,arn:aws:acm:us-east-1:202533518394:certificate/ff27f041-c3ee-4787-889d-5c80eeb91c16,arn:aws:acm:us-east-1:202533518394:certificate/233b3a93-555f-4233-a719-be39fed9bb18
  tls:
    - hosts:
        - auth.kometadeveloper.xyz
        - core.kometadeveloper.xyz
        - cards.kometadeveloper.xyz
      secretName: kometa-tls
  services:
    - host: auth.kometadeveloper.xyz
      paths:
        - path: /
          pathType: Prefix
          name: kometa-auth
          port: 80
    - host: core.kometadeveloper.xyz
      paths:
        - path: /
          pathType: Prefix
          name: kometa-core
          port: 80
    - host: cards.kometadeveloper.xyz
      paths:
        - path: /
          pathType: Prefix
          name: cards-service
          port: 80
    - host: marketplace.kometadeveloper.xyz
      paths:
        - path: /
          pathType: Prefix
          name: kometa-marketplace
          port: 80
    - host: tournament.kometadeveloper.xyz
      paths:
        - path: /
          pathType: Prefix
          name: kometa-tournament
          port: 80

auth:
  replicaCount: 1
  image:
    repository: 202533518394.dkr.ecr.us-east-1.amazonaws.com/kometa-auth
    tag: v1.0-develop-79
  resources:
    limits:
      memory: "200Mi"
      cpu: "200m"
    requests:
      memory: "150Mi"
      cpu: "150m"
  service:
    port: 4041
  ingress:
    host: auth.kometadeveloper.xyz
    paths:
      - path: /
        pathType: Prefix

core:
  replicaCount: 1
  image:
    repository: 202533518394.dkr.ecr.us-east-1.amazonaws.com/kometa-core
    tag: v1.0-develop-88
  resources:
    limits:
      memory: "200Mi"
      cpu: "200m"
    requests:
      memory: "150Mi"
      cpu: "150m"
  service:
    port: 4041
  ingress:
    host: core.kometadeveloper.xyz
    paths:
      - path: /
        pathType: Prefix

marketplace:
  replicaCount: 1
  image:
    repository: 202533518394.dkr.ecr.us-east-1.amazonaws.com/kometa-marketplace
    tag: v1.0-develop-74
  resources:
    limits:
      memory: "200Mi"
      cpu: "200m"
    requests:
      memory: "150Mi"
      cpu: "150m"
  service:
    port: 3000
  ingress:
    host: marketplace.kometadeveloper.xyz
    paths:
      - path: /
        pathType: Prefix

tournament:
  replicaCount: 1
  image:
    repository: 202533518394.dkr.ecr.us-east-1.amazonaws.com/kometa-tournament
    tag: v1.0-develop-27
  resources:
    limits:
      memory: "200Mi"
      cpu: "200m"
    requests:
      memory: "150Mi"
      cpu: "150m"
  service:
    port: 3000
  ingress:
    host: tournament.kometadeveloper.xyz
    paths:
      - path: /
        pathType: Prefix

cardsService:
  replicaCount: 1
  name: cards-service
  image:
    repository: 202533518394.dkr.ecr.us-east-1.amazonaws.com/tarjetas-service
    tag: v1.0-dev-89
  resources:
    limits:
      memory: "200Mi"
      cpu: "200m"
    requests:
      memory: "150Mi"
      cpu: "150m"
  service:
    port: 3000
  ingress:
    host: cards.kometadeveloper.xyz
    paths:
      - path: /
        pathType: Prefix

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

livenessProbe:
  httpGet:
    path: /
    port: http
readinessProbe:
  httpGet:
    path: /
    port: http

autoscaling:
  enabled: true
  minReplicas: 1
  maxReplicas: 2
  targetCPUUtilizationPercentage: 75
  targetMemoryUtilizationPercentage: 75

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}

# NEW RELIC

newrelic-infrastructure:
  # newrelic-infrastructure.enabled -- Install the [`newrelic-infrastructure` chart](https://github.com/newrelic/nri-kubernetes/tree/main/charts/newrelic-infrastructure)
  enabled: true

nri-prometheus:
  # nri-prometheus.enabled -- Install the [`nri-prometheus` chart](https://github.com/newrelic/nri-prometheus/tree/main/charts/nri-prometheus)
  enabled: false

nri-metadata-injection:
  # nri-metadata-injection.enabled -- Install the [`nri-metadata-injection` chart](https://github.com/newrelic/k8s-metadata-injection/tree/main/charts/nri-metadata-injection)
  enabled: true

kube-state-metrics:
  # kube-state-metrics.enabled -- Install the [`kube-state-metrics` chart](https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-state-metrics) from the stable helm charts repository.
  # This is mandatory if `infrastructure.enabled` is set to `true` and the user does not provide its own instance of KSM version >=1.8 and <=2.0. Note, kube-state-metrics v2+ disables labels/annotations
  # metrics by default. You can enable the target labels/annotations metrics to be monitored by using the metricLabelsAllowlist/metricAnnotationsAllowList options described [here](https://github.com/prometheus-community/helm-charts/blob/159cd8e4fb89b8b107dcc100287504bb91bf30e0/charts/kube-state-metrics/values.yaml#L274) in
  # your Kubernetes clusters.
  enabled: true

nri-kube-events:
  # nri-kube-events.enabled -- Install the [`nri-kube-events` chart](https://github.com/newrelic/nri-kube-events/tree/main/charts/nri-kube-events)
  enabled: true

newrelic-logging:
  # newrelic-logging.enabled -- Install the [`newrelic-logging` chart](https://github.com/newrelic/helm-charts/tree/master/charts/newrelic-logging)
  enabled: true
  # fluentBit:
    # -- What path will be mounted to read logs from the node
    # linuxMountPath: /var
    # persistence:
      # -- Fluent Bit persistence is needed to keep track of tailed logs, if set to none data loss or logs duplications could happen. Options are "hostPath", "none", "persistentVolume"
      # mode: hostPath
      # persistentVolume:
        # -- When using persistent volume a storage class could be needed depending on the cluster. It should be a storage class that allows ReadWriteMany
        # storageClass: 


newrelic-pixie:
  # newrelic-pixie.enabled -- Install the [`newrelic-pixie`](https://github.com/newrelic/helm-charts/tree/master/charts/newrelic-pixie)
  enabled: false

pixie-chart:
  # pixie-chart.enabled -- Install the [`pixie-chart` chart](https://docs.pixielabs.ai/installing-pixie/install-schemes/helm/#3.-deploy)
  enabled: false

newrelic-infra-operator:
  # newrelic-infra-operator.enabled -- Install the [`newrelic-infra-operator` chart](https://github.com/newrelic/newrelic-infra-operator/tree/main/charts/newrelic-infra-operator) (Beta)
  enabled: false

newrelic-prometheus-agent:
  # newrelic-prometheus-agent.enabled -- Install the [`newrelic-prometheus-agent` chart](https://github.com/newrelic/newrelic-prometheus-configurator/tree/main/charts/newrelic-prometheus-agent)
  enabled: true

newrelic-eapm-agent:
  # newrelic-eapm-agent.enabled -- Install the [`nr-eapm-agent`](https://github.com/newrelic/helm-charts/tree/master/charts/nr-ebpf-agent)
  enabled: false

k8s-agents-operator:
  # k8s-agents-operator.enabled -- Install the [`k8s-agents-operator` chart](https://github.com/newrelic/k8s-agents-operator/tree/main/charts/k8s-agents-operator)
  enabled: true

newrelic-k8s-metrics-adapter:
  # newrelic-k8s-metrics-adapter.enabled -- Install the [`newrelic-k8s-metrics-adapter.` chart](https://github.com/newrelic/newrelic-k8s-metrics-adapter/tree/main/charts/newrelic-k8s-metrics-adapter) (Beta)
  enabled: false


# -- change the behaviour globally to all the supported helm charts.
# See [user's guide of the common library](https://github.com/newrelic/helm-charts/blob/master/library/common-library/README.md) for further information.
# @default -- See [`values.yaml`](values.yaml)
global:
  # -- The cluster name for the Kubernetes cluster.
  cluster: kometa-dev

  # -- The license key for your New Relic Account. This will be preferred configuration option if both `licenseKey` and `customSecret` are specified.
  licenseKey: 22a03856277160ab4c16960602499de6FFFFNRAL
  # -- The license key for your New Relic Account. This will be preferred configuration option if both `insightsKey` and `customSecret` are specified.
  insightsKey: ""
  # -- Name of the Secret object where the license key is stored
  customSecretName: ""
  # -- Key in the Secret object where the license key is stored
  customSecretLicenseKey: ""

  # -- Additional labels for chart objects
  labels: {}
  # -- Additional labels for chart pods
  podLabels: {}

  images:
    # -- Changes the registry where to get the images. Useful when there is an internal image cache/proxy
    registry: ""
    # -- Set secrets to be able to fetch images
    pullSecrets: []

  serviceAccount:
    # -- Add these annotations to the service account we create
    annotations: {}
    # -- Configures if the service account should be created or not
    create:
    # -- Change the name of the service account. This is honored if you disable on this chart the creation of the service account so you can use your own
    name:

  # -- (bool) Sets pod's hostNetwork
  # @default -- false
  hostNetwork:
  # -- Sets pod's dnsConfig
  dnsConfig: {}

  # -- Sets pod's priorityClassName
  priorityClassName: ""
  # -- Sets security context (at pod level)
  podSecurityContext: {}
  # -- Sets security context (at container level)
  containerSecurityContext: {}

  # -- Sets pod/node affinities
  affinity: {}
  # -- Sets pod's node selector
  nodeSelector: {}
  # -- Sets pod's tolerations to node taints
  tolerations: []

  # -- Adds extra attributes to the cluster and all the metrics emitted to the backend
  customAttributes: {}

  # -- (bool) Reduces number of metrics sent in order to reduce costs
  # @default -- false
  lowDataMode: true

  # -- (bool) In each integration it has different behavior. See [Further information](#values-managed-globally-3) but all aims to send less metrics to the backend to try to save costs |
  # @default -- false
  privileged: true

  # -- (bool) Must be set to `true` when deploying in an EKS Fargate environment
  # @default -- false
  fargate:

  # -- Configures the integration to send all HTTP/HTTPS request through the proxy in that URL. The URL should have a standard format like `https://user:password@hostname:port`
  proxy:  

  # -- (bool) Send the metrics to the staging backend. Requires a valid staging license key
  # @default -- false
  nrStaging:
  fedramp:
    # fedramp.enabled -- (bool) Enables FedRAMP
    # @default -- false
    enabled: 

  # -- (bool) Sets the debug logs to this integration or all integrations if it is set globally
  # @default -- false
  verboseLog:


  # To add values to the subcharts. Follow Helm's guide: https://helm.sh/docs/chart_template_guide/subcharts_and_globals

  # If you wish to monitor services running on Kubernetes you can provide integrations
  # configuration under `integrations_config` that it will passed down to the `newrelic-infrastructure` chart.
  #
  # You just need to create a new entry where the "name" is the filename of the configuration file and the data is the content of
  # the integration configuration. The name must end in ".yaml" as this will be the
  # filename generated and the Infrastructure agent only looks for YAML files.
  #
  # The data part is the actual integration configuration as described in the spec here:
  # https://docs.newrelic.com/docs/integrations/integrations-sdk/file-specifications/integration-configuration-file-specifications-agent-v180
  #
  # In the following example you can see how to monitor a Redis integration with autodiscovery
  #
  #
  # newrelic-infrastructure:
  #   integrations:
  #     nri-redis-sampleapp:
  #       discovery:
  #         command:
  #           exec: /var/db/newrelic-infra/nri-discovery-kubernetes --tls --port 10250
  #           match:
  #             label.app: sampleapp
  #       integrations:
  #         - name: nri-redis
  #           env:
  #             # using the discovered IP as the hostname address
  #             HOSTNAME: ${discovery.ip}
  #             PORT: 6379
  #           labels:
  #             env: test

